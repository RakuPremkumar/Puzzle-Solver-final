<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="BoxlineReductionExplanation" xml:space="preserve">
    <value>Box line reduction occurs when a number only appears twice or three times in the same row or column, while also being a part of the same cage. If this does happen then you can remove that number as a possibility from other cells within the same cage that aren't in the original row or column. As shown on the left where the two 4s in cells (A,8) and (B,8) are the only 4s in column 8 and they are both in cage 3. this then means we can remove 4 as a possibility from cells (B,7), (B,9) and (C,9) because they are in the same cage.</value>
    <comment>this text will not take up muliple lines in the code and when it is called to, through resources it acts as a normal string.</comment>
  </data>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="Box_line_reduction_1" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Box line reduction 1.PNG;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="Box_line_reduction_2" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Box line reduction 2.PNG;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="HiddenSingleExplanation" xml:space="preserve">
    <value>Hidden singles occurs when a number is only able to appear once within a column, row or cage. This means that a number only has one cell in a column, row or cage that it can be put into. As shown on the left in cell D2 the 7 is only able to go into that cell for that same cage. Similarly the 7 in cell F6 is the only 7 that appears in that same row which means we can solve these 2 numbers as shown.</value>
    <comment>same as above</comment>
  </data>
  <data name="Hidden_singles_1" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Hidden singles 1.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="Hidden_singles_2" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Hidden singles 2.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="NakedPairExplanation" xml:space="preserve">
    <value>Naked pairs are when there are two cells that share the same numbers as possibilities and they each only have those two numbers as possibility and they share either a row column or cage. If this does occur then you can remove both those numbers as possibilities from other cells based on what unit they share together. This is shown on the left where the numbers 2 and 8 are they only numbers in cell (H,8) and (G,8) and they are in the same column,8. This means the 2 in cell (C,8) can be removed as a possibility.</value>
    <comment>same as above</comment>
  </data>
  <data name="Naked_Pairs_1" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Naked Pairs 1.PNG;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="Naked_Pairs_2" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Naked Pairs 2.PNG;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="PointingPairsExplanation" xml:space="preserve">
    <value>Pointing paris occurs when, in one cage a number only appears as a possibility two or three times and each apperence is in the same row or colmun. This means that you can eliminate that number as a possibilty from cells in the same row as the pairs or triple outside the initial cage. on the left it shows the number 2 in cells G4 and G5 as being the only 2s in cage 8 (highlighted in green). It then removes the 2 in cell G2 as a possibility(highlighted in yellow).</value>
    <comment>same as above</comment>
  </data>
  <data name="Pointing_pairs_1" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Pointing pairs 1.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="Pointing_pairs_2" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Pointing pairs 2.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="SolvedCellExplanation" xml:space="preserve">
    <value>Wherever there is only one possibility in a cell, we can solve this cell as only that one number is able to go in that cell. Shown by the cells A8 and J8 where they both only have one possibility each the 9 and the 6 respectively and we can now fill in the cell with that number as shown on the left.</value>
    <comment>same as above</comment>
  </data>
  <data name="Solved_Cell_1" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Solved Cell 1.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="Solved_cell_2" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\Solved cell 2.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
</root>